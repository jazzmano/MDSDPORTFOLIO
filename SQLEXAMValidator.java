/*
 * generated by Xtext 2.25.0
 */
package org.xtext.example.mydsl1.validation;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import javax.annotation.processing.Generated;

import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.XtextPackage.Literals;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.mydsl1.sQLEXAM.Add;
import org.xtext.example.mydsl1.sQLEXAM.Attribute;
import org.xtext.example.mydsl1.sQLEXAM.Expression;
import org.xtext.example.mydsl1.sQLEXAM.MathExp;
import org.xtext.example.mydsl1.sQLEXAM.Numbers;
import org.xtext.example.mydsl1.sQLEXAM.Plus;
import org.xtext.example.mydsl1.sQLEXAM.Relationship;
import org.xtext.example.mydsl1.sQLEXAM.SQLSystem;
import org.xtext.example.mydsl1.sQLEXAM.Select;


/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SQLEXAMValidator extends AbstractSQLEXAMValidator {
	
	//Method that validates that attribute duplicate names do not occur
	@Check 
	public void DuplicateAddAttributes(Add entity) {
		List<String> attList = new ArrayList<String>();
		
		// fill the list with the names 
		for(int i = 0; i<entity.getAttributes().size();i++) {
			attList.add(entity.getAttributes().get(i).getName());
		}
		Set<String> attSet = new HashSet<String>(attList);
		if(attSet.size()<attList.size()) {
			error("No duplicate names are allowed",null); //TODO : find ud af hvordan man tilføjer den røde linje til præcis attribut navnet
			
		}
	}
	//Method to prevent underscores being used, we only allow attributes naming conventions like 
	// thisIsAllowed.
	
	@Check 
	public void specialCharacterCheck(Add entity) {
		char[] specialChars = {'_'}; 
		for(int i = 0; i < entity.getAttributes().size(); i++) {
			for(int j = 0; j<entity.getAttributes().get(i).getName().length(); j++){
				System.out.println(entity.getAttributes().get(i).getName());
				if(entity.getAttributes().get(i).getName().charAt(j) == specialChars[0]) {
					error("_ is not Allowed", null);
				}
			}
		}
	}
	@Check 
	public void checkForCapitalLetters(Add entity) {
		for(int i = 0; i<entity.getAttributes().size(); i++) {
			for(int j = 0; j<entity.getAttributes().get(i).getName().length(); j++){
				System.out.println(entity.getAttributes().get(i).getName());
				if(Character.isUpperCase(entity.getAttributes().get(i).getName().charAt(0))) {
					warning("Lower case is preffered for first letters in attribute naming", null);
				}
			}
		}
	}
	
	@Check 
	public void checkDuplicateNamesForeignKey(Relationship entity) {
		List<String> attList = new ArrayList<String>();

		// fill the list with the names 
		for(int i = 0; i<entity.getForeignkey().size();i++) {
			attList.add(entity.getForeignkey().get(i).getName());
		}
		Set<String> attSet = new HashSet<String>(attList);
		if(attSet.size()<attList.size()) {
			error("No duplicate names are allowed",null); //TODO : find ud af hvordan man tilføjer den røde linje til præcis attribut navnet
			
		}
	}
	//No duplicates for select names
	@Check
	public void checkDuplicateNamesSelect(SQLSystem entity) {
		List<String> selectList = new ArrayList<String>();
		for(int i = 0 ; i<entity.getOperation().size();i++) {
			//selectList.add(entity.getOperation().get(i).getName());
		}
		Set<String> attSet = new HashSet<String>(selectList);
		if(attSet.size()<selectList.size()) {
			error("No duplicate names are allowed",null); //TODO : find ud af hvordan man tilføjer den røde linje til præcis attribut navnet
			
		}
	}
}
